Software development involves the design, development, testing, deployment, and maintenance of software products to solve real world problems. Example of software engineering is developing a company website while traditional programming is writing a script to automate file back-up. Software Development Life Cycle (SDLC): Software engineering is a disciplined approach to software development that spans the full lifecycle, from requirements analysis to maintenance, with an emphasis on quality, efficiency, and meeting user expectations. It employs organized techniques and cross-functional teams to oversee both technical and managerial issues. Principal Distinctions from Traditional Programming; Software engineering encompasses the entire development lifecycle, whereas traditional programming is mostly concerned with writing code. 1. Process: While Traditional programming may not adhere to formal processes, software engineering does. 2. Team Participation: Software engineering encompasses many jobs than just programming. 3. Quality and Standards: Software engineering places a strong emphasis on standards and quality assurance. 4. Documentation and Maintenance: In software engineering, comprehensive documentation and continuous maintenance are essential. 5. Risk management: Software engineering uses a systematic approach to risk management. Software engineering is really more than simply writing code; it's about using engineering concepts to build dependable and maintainable software systems.
The Software Development Life Cycle (SDLC) is a structured process for creating software. It includes planning, analysis, design, implementation, testing, deployment, and maintenance phases. 1. Planning phase -  project goals and requirements are gathered. 2. Analysis phase ensures requirements are clear and feasible. 3. Design phase involves creating the software architecture and technical specifications i.e user interfaces. 4. Implementation phase is the coding and development stage. 5. Testing phase identifies and fixes defects or bugs and ensures the software meets the quality standards. 6. Deployment phase involves installing and configuring the software for production and distribution to users. 7. Maintenance phase includes ongoing monitoring, updates, and support.
The Waterfall model follows a linear progression through defined phases and includes detailed documentation, is best suited for steady requirements. Agile, on the other hand, is iterative and adaptable, emphasizing communication and working software above documentation, making it appropriate for dynamic or evolving needs. Key Differences: 1. Approach: Agile is iterative and adaptive, while Waterfall is sequential and rigid. 2. Flexibility: Agile allows for changes and adjustments throughout the project, whereas Waterfall is less flexible once development begins. 3. Collaboration: Agile encourages close collaboration between teams and stakeholders, whereas Waterfall typically involves less interaction between phases. 4. Documentation: Agile prioritizes working software over extensive documentation, whereas Waterfall emphasizes detailed documentation at each stage. 
Preferred Scenarios:Agile is preferred for projects with evolving or uncertain requirements, where flexibility and continuous adaptation are essential. It is also suitable for projects requiring frequent releases and customer involvement. On the other hand, Waterfall is preferred for projects with well-defined and stable requirements, where a sequential and disciplined approach is appropriate. It is also suitable for projects where extensive documentation is necessary or where regulatory compliance is required.
Requirements engineering is the systematic process of developing, documenting, and managing software requirements. It entails eliciting, evaluating, specifying, validating, and monitoring requirements throughout the software development process. The goal is for stakeholders and the development team to share a similar understanding in order to create the best product that meets objectives and quality standards. Collaboration, communication, and continuous feedback enable effective requirements engineering to limit risks, decrease rework, and assure alignment between the software solution and the needs of stakeholders.
Modularity refers to the breakdown of a system into smaller, self-contained, and replaceable modules or components. Each module in the system performs a specific function or task and can be designed, tested, and maintained individually.
Here's how modularity enhances maintainability and scalability: 1. Isolation of concerns - Each module focuses on one component of the system's functionality. This separation enables developers to analyze, edit, and troubleshoot particular modules without affecting the entire system. It improves code readability, maintainability, and ease of troubleshooting. 2. Code Reusability - The modular design promotes reusable components. Once a module has been designed and tested, it can be reused in other sections of the system or in different projects entirely. This reduces development time and effort while promoting consistency across projects. 3. Scalability - Modular design facilitates scaling as the system's complexity or size increases. New features or functionalities can be incorporated by simply adding new modules or expanding existing ones, without having to redesign the complete. 4. Parallel development allows teams to work on multiple modules at the same time, which speeds up the development process. Because modules are separate, developers can concentrate on their assigned modules without waiting for other sections of the system to be finished. This parallel development technique boosts productivity and reduces time-to-market. 5. Each module can be tested independently, allowing for automated testing and ensuring that modifications or upgrades to one module do not unintentionally influence others. Maintenance becomes more straightforward since developers can simply discover and correct errors within certain modules without disturbing the overall system.
Software testing is the process of verifying that a software product is doing what it is supposed to do. 1. Unit testing - Individual units or components of a software are tested in isolation.2. Integration testing involves testing interactions between different units or modules to ensure they work together as intended. 3. System testing - evaluates the entire system as a whole to ensure it meets the specified requirements. 4. Acceptance testing - It is the final phase of testing where software is tested against user requirements to ensure it meets user needs.  Testing is critical in software development for detecting bugs, ensuring quality, mitigating risks, and satisfying customers. It aids in early fault detection, ensures high-quality products, reduces risks, and improves user satisfaction.
Version Control Systems (VCS) are software tools that help manage and track changes to source code and coordinating work among team members.  Importance of VCS: 1. VCS enables developers to collaborate on the same project concurrently without overwriting each other's work. 2. VCS keeps a complete record of changes inclusive of who made them and why thereby helping developers to revert to past versions as needed and better comprehend the project's evolution. 3. VCS supports branching, allowing developers to construct independent lines of development. This is useful for developing new features or fixes in isolation before integrating them into the main codebase. 4. VCS stores the complete project in a repository, creating a backup that can be recovered in the event of data loss. 5. VCS improves transparency and traceability in the development by tracking who made specific changes and when. 
Examples of popular VCS and their features: 1. Git. Features; Distributed version control, high performance, strong branching and merging capabilities, extensive support for collaboration. 2. Subversion (SVN). Features; Centralized version control, atomic commits, directory versioning, efficient handling of binary files, detailed history and metadata tracking. 3. Mercurial. Features; Simple interface, robust branching and merging, high performance with large repositories, Distributed version control. 4. Perforce (Helix Core). Features; Centralized version control, high performance with large binary files, Strong support for branching and merging, advanced security features.
A software project manager oversees the planning, execution and delivery of software projects. The key responsibilities of a project manager are: Project planning, team management, stakeholder communication and status reporting, risk management, quality assurance, budgeting and change management. 
Challenges faced in managing software projects include; Scope creep, time management by ensuring projects stay on schedule despite unforeseen delays, balancing limited resources, managing diverse teams distributed across different locations and time zones, communication issues, proactively identifying and mitigating risks in an uncertain project environment, ensuring the final product meets all quality standards and requirements often under tight deadlines, managing client expectations, technological challenges and budget overruns.
Software maintenance is the process of upgrading and modifying software after it has been deployed in order to fix bugs, improve performance or adapt to changes. There are 4 categories of maintenance activities: 1. Corrective maintenance- involves fixing bugs and errors. 2. Adaptive maintenance - tailoring software to new settings or requirements. 3. Perfective maintenance - improves performance and introduces new features. 4. Preventive maintenance - reduces future problems and improves maintainability. Maintenance is critical in the software lifecycle because it assures lifespan, improves performance, addresses bugs, adjusts to changes, prevents future problems and maintains compliance, assuring the products functionality and relevance over time.
Software engineers must deal with ethical issues such as privacy violations, security flaws, intellectual property infringement, bias and discrimination, lack of transparency, quality and reliability concerns and workplace ethics. To meet ethical standards software engineers must; follow professional codes of ethics, commit to privacy and security best practices, promote transparency, implement fair and unbiased systems, respect intellectual property, ensure software quality and reliability, make ethical decisions, accept responsibility and maintain workplace integrity. This ensures the creation of an ethical and trustworthy software.
